#version 150

uniform bool use_group_point_size;
//uniform float group_point_sizes[250];
uniform bool use_color_index;
uniform vec4 palette[64]; // todo: can be optimized

//
uniform vec3 headset_position;
uniform vec3 headset_direction;
uniform float headset_culling_range;

uniform vec3 left_controller_position;
uniform vec3 right_controller_position;
uniform float controller_effect_range;

uniform bool enable_acloud_effect;
uniform bool enable_headset_culling;

in float point_size;
in vec4 position;
in vec3 normal;
in vec4 color;
in uint color_index;

in int group_index;

out vec3 normal_gs;
out vec4 color_gs;
out float ignore;

//***** begin interface of view.glsl ***********************************
mat4 get_modelview_matrix();
mat4 get_projection_matrix();
mat4 get_modelview_projection_matrix();
mat4 get_inverse_modelview_matrix();
mat4 get_inverse_modelview_projection_matrix();
mat3 get_normal_matrix();
mat3 get_inverse_normal_matrix();
//***** end interface of view.glsl ***********************************

//***** begin interface of group.glsl ***********************************
vec4 group_color(in vec4 color, int group_index);
vec3 group_transformed_position(in vec3 position, int group_index);
vec3 group_transformed_normal(in vec3 nml, int group_index);
void right_multiply_group_normal_matrix(inout mat3 NM, int group_index);
void right_multiply_group_position_matrix(inout mat4 PM, int group_index);
void right_multiply_group_normal_matrix_and_rotation(inout mat3 NM, int group_index, vec4 rotation);
void right_multiply_group_position_matrix_and_rigid(inout mat4 PM, int group_index, vec4 rotation, vec3 translation);
//***** end interface of group.glsl ***********************************

void main()
{
	//if (use_group_point_size) {
		//gl_PointSize = group_point_sizes[group_index];
	//}
	//else {
		gl_PointSize = point_size;
	//}

	// initialize with not ignore 
	ignore = 0;

	// culling with headset 
	if(ignore < 0.5){ // if not ignored
		if(enable_headset_culling){
			if(
				(distance(position.xyz,headset_position)>headset_culling_range) 
				|| (dot(normalize(position.xyz-headset_position),normalize(headset_direction))<0.5)
			){
				ignore = 1;
			}
			else 
				ignore = 0;				
		}else{
			ignore = 0;
		}
	}

	// compare with controller position 
	if(ignore < 0.5){ // if not ignored
		if(enable_acloud_effect){
			if(distance(position.xyz,right_controller_position)<controller_effect_range){
				ignore = 1;
			}
			else 
				ignore = 0;				
		}else{
			ignore = 0;
		}
	}

	if(ignore < 0.5){ // if not ignored 
		if (use_color_index)
			color_gs = group_color(vec4(palette[color_index]), group_index);
		else
			color_gs = group_color(color, group_index);
		normal_gs = group_transformed_normal(normal, group_index);
		gl_Position = vec4(group_transformed_position(position.xyz, group_index), 1.0);
	}
}